<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8" />
  <title>Terract ‚Äî Tower Race</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root {
      --bg: #0b0f17;
      --panel: #101826;
      --text: #e8f0ff;
      --muted: #7b8aa0;
      --accent: #7aa2ff;
      --good: #2ecc71;
      --warn: #f1c40f;
      --bad: #e74c3c;
      --grid: #1a2436;
      --board-bg: #0d1421;
      --board-border: #2c3e50;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif;
    }

    #game {
      height: 100vh;
      display: grid;
      grid-template-columns: 1fr auto;
      grid-template-rows: auto 1fr;
      grid-template-areas: "header header" "board sidebar";
    }

    #authOverlay {
      position: fixed;
      inset: 0;
      display: flex;
      align-items: center;
      justify-content: center;
      background: var(--bg);
      z-index: 10;
    }

    #authOverlay .error {
      color: var(--bad);
      margin-top: 8px;
    }

    header {
      grid-area: header;
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 14px;
      background: #0d1524;
      border-bottom: 1px solid #18243a;
    }

    header h1 {
      margin: 0;
      font-size: 16px;
      letter-spacing: .5px;
      color: var(--muted);
    }

    header .right {
      display: flex;
      gap: 16px;
      align-items: center;
    }

    #gravity {
      color: var(--muted);
      font-size: 12px;
    }

    #status {
      font-weight: 600;
      color: var(--accent);
    }

    .wrap {
      grid-area: board;
      display: flex;
      justify-content: center;
      align-items: center;
      padding: 10px;
    }

    canvas {
      background: var(--board-bg);
      border: none;
      border-radius: 0;
      box-shadow: none;
    }

    aside {
      grid-area: sidebar;
      width: 260px;
      background: var(--panel);
      border-left: 1px solid #18243a;
      padding: 12px;
      display: flex;
      flex-direction: column;
      gap: 12px;
    }

    .card {
      background: #0e1727;
      border: 1px solid #1a2741;
      border-radius: 12px;
      padding: 12px;
    }

    .row {
      display: flex;
      gap: 8px;
      align-items: center;
    }

    .apbar {
      height: 8px;
      background: #0a1220;
      border-radius: 999px;
      overflow: hidden;
      border: 1px solid #1a2741;
    }

    .apfill {
      height: 100%;
      background: linear-gradient(90deg, #7aa2ff, #81ecec);
      width: 0%;
    }

    .players {
      display: grid;
      gap: 8px;
    }

    .p {
      display: grid;
      grid-template-columns: 16px 1fr auto;
      gap: 8px;
      align-items: center;
      font-size: 13px;
    }

    .p.turn {
      background: rgba(122, 162, 255, 0.15);
      border-radius: 6px;
      padding: 2px 4px;
    }

    .p.eliminated {
      opacity: 0.5;
      text-decoration: line-through;
    }

    .dot {
      width: 12px;
      height: 12px;
      border-radius: 50%;
    }

    .muted {
      color: var(--muted);
    }

    button {
      height: 38px;
      padding: 0 12px;
      border-radius: 10px;
      border: 1px solid #243244;
      background: #0a1222;
      color: var(--text);
      outline: none;
      cursor: pointer;
      transition: border-color .15s ease, transform .05s ease, background .15s ease;
    }

    input {
      height: 38px;
      padding: 0 12px;
      border-radius: 10px;
      border: 1px solid #243244;
      background: #0a1222;
      color: var(--text);
      outline: none;
    }

    input:focus {
      border-color: #365072;
    }

    .btn {
      border-color: transparent;
    }

    .btn.primary {
      background: var(--accent);
    }

    .btn.success {
      background: var(--good);
    }

    button:active {
      transform: translateY(1px);
    }

    button.selected {
      background: var(--accent);
      border-color: var(--accent);
    }

    .hint {
      font-size: 12px;
      color: var(--muted);
      text-align: center;
    }

    @media (max-width: 760px) {
      body {
        grid-template-columns: 1fr;
        grid-template-rows: auto auto 1fr;
        grid-template-areas: "header" "sidebar" "board";
      }

      aside {
        width: auto;
      }
    }
  </style>
</head>

<body>
  <div id="authOverlay">
    <div class="card">
      <div class="row">
        <input id="name" placeholder="Your name" />
        <input id="code" placeholder="Lobby code" style="width:140px;text-transform:uppercase;" />
        <button id="createBtn" class="btn success">Create lobby</button>
        <button id="joinBtn" class="btn primary">Join</button>
      </div>
      <div class="error" id="err"></div>
    </div>
  </div>

  <div id="game" style="display:none;">
    <header>
      <h1>Terract ‚Äî Tower Race</h1>
      <div class="right">
        <div id="roomCode" class="muted"></div>
        <button id="copyLinkBtn" class="btn">Copy Link</button>
        <button id="startBtn" style="display:none;">Start</button>
        <button id="restartBtn" style="display:none;">Restart</button>
        <input id="maxPointsInput" type="number" min="1" style="width:60px;display:none;" />
        <button id="setMaxPointsBtn" style="display:none;">Set</button>
        <div id="gravity" class="muted">Speed: ‚Äî</div>
        <div id="status">Connecting‚Ä¶</div>
      </div>
    </header>

    <div class="wrap">
      <canvas id="board" width="240" height="480"></canvas>
    </div>

    <aside>
      <div class="card">
        <div class="players" id="players"></div>
      </div>

      <div class="card hint" id="controlsCard">
        Controls: ‚Üê ‚Üí move, Q/E rotate, ‚Üë rotate, ‚Üì soft drop, Space hard drop.
      </div>
    </aside>
  </div>

  <script>
    (() => {
      const size = 20; // px
      const headspace = 6; // rows shown above the board (increased for opponent pieces)
      const canvas = document.getElementById('board');
      const ctx = canvas.getContext('2d');
      const statusEl = document.getElementById('status');
      const gravityEl = document.getElementById('gravity');
      const playersEl = document.getElementById('players');
      const startBtn = document.getElementById('startBtn');
      const restartBtn = document.getElementById('restartBtn');
      const roomCodeEl = document.getElementById('roomCode');
      const gameEl = document.getElementById('game');
      const authOverlay = document.getElementById('authOverlay');
      const nameInput = document.getElementById('name');
      const codeInput = document.getElementById('code');
      const createBtn = document.getElementById('createBtn');
      const joinBtn = document.getElementById('joinBtn');
      const errEl = document.getElementById('err');
      const copyLinkBtn = document.getElementById('copyLinkBtn');
      const maxPointsInput = document.getElementById('maxPointsInput');
      const setMaxPointsBtn = document.getElementById('setMaxPointsBtn');
      let ws = null;
      let me = null; // my id
      let width = 6, height = 24;
      let board = Array.from({ length: height }, () => Array(width).fill(null));
      let players = {};
      let currentTurn = null;
      let hostId = null;
      let currentRoom = '';
      let gameStarted = false;
      let winnerId = null;
      let maxPoints = 10;

      const params = new URLSearchParams(location.search);
      const urlCode = params.get('code');
      if (urlCode) codeInput.value = urlCode.toUpperCase();

      startBtn.onclick = () => send({ type: 'start', id: me });
      restartBtn.onclick = () => send({ type: 'restart', id: me });

      function startGame(roomCode, userName) {
        errEl.textContent = '';
        authOverlay.style.display = 'none';
        gameEl.style.display = 'grid';
        roomCodeEl.textContent = `Room: ${roomCode}`;
        currentRoom = roomCode;
        ws = new WebSocket((location.protocol === 'https:' ? 'wss://' : 'ws://') + location.host + '/racing?room=' + roomCode + '&name=' + encodeURIComponent(userName));
        ws.onopen = () => statusEl.textContent = 'Joined. Waiting for others‚Ä¶';
        ws.onclose = () => statusEl.textContent = 'Disconnected';
        ws.onmessage = (ev) => {
          const msg = JSON.parse(ev.data);
          if (msg.type === 'welcome') {
            me = msg.id; width = msg.width; height = msg.height; currentTurn = msg.turnId || null; hostId = msg.hostId; maxPoints = msg.maxPoints || maxPoints;
            canvas.width = width * size; canvas.height = (height + headspace + 1) * size;
            board = Array.from({ length: height }, () => Array(width).fill(null));
            if (hostId === me) maxPointsInput.value = maxPoints;
          }
          if (msg.type === 'state') {
            if (msg.width && msg.height && (msg.width !== width || msg.height !== height)) {
              width = msg.width; height = msg.height;
              canvas.width = width * size; canvas.height = (height + headspace + 1) * size;
              board = Array.from({ length: height }, () => Array(width).fill(null));
            }
            board = msg.board;
            players = msg.players;
            currentTurn = msg.turnId;
            hostId = msg.hostId;
            winnerId = msg.winnerId || null;
            gameStarted = msg.started && !winnerId;
            maxPoints = msg.maxPoints;
            renderPlayersList();
            draw();
            startBtn.style.display = hostId === me && !msg.started ? 'inline-block' : 'none';
            restartBtn.style.display = hostId === me && msg.started ? 'inline-block' : 'none';
            maxPointsInput.style.display = hostId === me ? 'inline-block' : 'none';
            setMaxPointsBtn.style.display = hostId === me ? 'inline-block' : 'none';
            if (hostId === me) maxPointsInput.value = msg.maxPoints;
            if (currentTurn === me) statusEl.textContent = 'Your turn';
            else statusEl.textContent = 'Waiting‚Ä¶';
          }
          if (msg.type === 'event') {
            if (msg.kind === 'pointsGain' && msg.playerId === me) {
              statusEl.textContent = `+${msg.gain} pts ‚Üí ${msg.points}`;
              setTimeout(() => statusEl.textContent = 'Playing‚Ä¶', 800);
            }
            if (msg.kind === 'speedUp') {
              gravityEl.textContent = `Speed: ${Math.round(1000 / msg.gravityMs)}Hz fall`;
            }
            if (msg.kind === 'eliminated') {
              const name = msg.name || 'Player';
              statusEl.textContent = `${name} eliminated`;
              setTimeout(() => statusEl.textContent = 'Playing‚Ä¶', 1000);
            }
          }
          if (msg.type === 'winner') {
            const who = players[msg.winnerId]?.name || 'Player';
            statusEl.textContent = `üèÜ ${who} wins!`;
            winnerId = msg.winnerId;
            gameStarted = false;
            renderPlayersList();
          }
        };
      }

      createBtn.onclick = () => {
        const name = nameInput.value.trim();
        if (!name) { errEl.textContent = 'Enter name'; return; }
        const code = Math.random().toString(36).slice(2, 8).toUpperCase();
        startGame(code, name);
      };
      joinBtn.onclick = () => {
        const name = nameInput.value.trim();
        const code = codeInput.value.trim().toUpperCase();
        if (!name || !code) { errEl.textContent = 'Enter name and code'; return; }
        startGame(code, name);
      };

      copyLinkBtn.onclick = () => {
        const link = `${location.origin}${location.pathname}?code=${currentRoom}`;
        navigator.clipboard.writeText(link);
        copyLinkBtn.textContent = 'Copied!';
        setTimeout(() => copyLinkBtn.textContent = 'Copy Link', 1500);
      };

      setMaxPointsBtn.onclick = () => {
        const val = parseInt(maxPointsInput.value, 10);
        if (Number.isFinite(val) && val > 0) {
          send({ type: 'setMaxPoints', id: me, maxPoints: val });
        }
      };
      function draw() {
        ctx.clearRect(0, 0, canvas.width, canvas.height);

        const playAreaStartY = (headspace + 1) * size;
        ctx.fillStyle = getComputedStyle(document.documentElement)
          .getPropertyValue('--bg') || '#0b0f17';
        ctx.fillRect(0, 0, width * size, playAreaStartY);
        // --- Draw border + separator line ---
        ctx.strokeStyle = 'rgba(122, 162, 255, 0.4)';
        ctx.lineWidth = 2;
        ctx.beginPath();
        ctx.moveTo(0, playAreaStartY - 1);
        ctx.lineTo(width * size, playAreaStartY - 1);
        ctx.stroke();

        ctx.strokeStyle = 'var(--board-border)';
        ctx.lineWidth = 3;
        ctx.strokeRect(0, playAreaStartY, width * size, height * size);

        // --- Grid background (main play area only) ---
        ctx.strokeStyle = 'rgba(26, 36, 54, 0.3)';
        ctx.lineWidth = 0.5;

        // Vertical grid lines
        for (let x = 0; x <= width; x++) {
          ctx.beginPath();
          ctx.moveTo(x * size, playAreaStartY);
          ctx.lineTo(x * size, canvas.height);
          ctx.stroke();
        }

        // Horizontal grid lines
        for (let y = headspace + 1; y <= height + headspace + 1; y++) {
          ctx.beginPath();
          ctx.moveTo(0, y * size);
          ctx.lineTo(width * size, y * size);
          ctx.stroke();
        }

        // --- Column numbers (above border, below pieces) ---
        ctx.fillStyle = '#7b8aa0';
        ctx.font = '10px monospace';
        ctx.textAlign = 'center';
        for (let x = 0; x < width; x++) {
          ctx.fillText(x, x * size + size / 2, playAreaStartY - 8);
        }

        // --- Settled pieces ---
        for (let y = 0; y < board.length; y++) {
          for (let x = 0; x < board[y].length; x++) {
            const c = board[y][x];
            if (c) {
              const drawX = x * size;
              const drawY = (y + headspace + 1) * size;

              // Main piece fill
              ctx.fillStyle = c;
              ctx.fillRect(drawX + 1, drawY + 1, size - 2, size - 2);

              // Subtle border
              ctx.strokeStyle = 'rgba(20, 32, 51, 0.6)';
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX + 0.5, drawY + 0.5, size - 1, size - 1);

              // Highlight
              ctx.strokeStyle = 'rgba(255, 255, 255, 0.1)';
              ctx.lineWidth = 1;
              ctx.strokeRect(drawX + 1.5, drawY + 1.5, size - 3, size - 3);
            }
          }
        }

        // --- Active & presummoned pieces ---
        Object.values(players).forEach(p => {
          if (!p.active) return;
          const mat = getShape(p.active.kind, p.active.rot);
          const isCurrentPlayer = (p.id === currentTurn);
          const isNextPlayer = getNextPlayerId() === p.id;

          let opacity = 1.0;
          let glowIntensity = 0;
          if (isCurrentPlayer) {
            opacity = 1.0; glowIntensity = 0.6;
          } else if (isNextPlayer) {
            opacity = 0.8; glowIntensity = 0.3;
          } else {
            opacity = 0.5;
          }

          for (let r = 0; r < mat.length; r++) {
            for (let c = 0; c < mat[r].length; c++) {
              if (mat[r][c]) {
                const rawY = p.active.y + r;
                const drawX = (p.active.x + c) * size;

                // Shift presummoned piece ABOVE the numbers
                let drawY;
                if (rawY < 0) {
                  drawY = (rawY + headspace) * size;   // higher
                } else {
                  drawY = (rawY + headspace + 1) * size;
                }

                const isAbovePlayArea = rawY < 0;

                if (isAbovePlayArea) {
                  // Preview area (simple rendering)
                  ctx.globalAlpha = opacity;
                  ctx.fillStyle = p.color;
                  ctx.fillRect(drawX, drawY, size, size);
                  ctx.globalAlpha = 1;
                } else {
                  // Main play area rendering
                  if (glowIntensity > 0) {
                    ctx.shadowColor = p.color;
                    ctx.shadowBlur = 10 * glowIntensity;
                  } else {
                    ctx.shadowBlur = 0;
                  }

                  ctx.globalAlpha = opacity;
                  ctx.fillStyle = p.color;
                  ctx.fillRect(drawX + 1, drawY + 1, size - 2, size - 2);

                  ctx.shadowBlur = 0;
                  ctx.globalAlpha = 1;

                  // Piece border
                  ctx.strokeStyle = 'rgba(20, 32, 51, 0.8)';
                  ctx.lineWidth = 1;
                  ctx.strokeRect(drawX + 0.5, drawY + 0.5, size - 1, size - 1);

                  // Highlight for current player
                  if (isCurrentPlayer) {
                    ctx.strokeStyle = 'rgba(255, 255, 255, 0.3)';
                    ctx.lineWidth = 1;
                    ctx.strokeRect(drawX + 1.5, drawY + 1.5, size - 3, size - 3);
                  }
                }
              }
            }
          }
        });
      }

      function getNextPlayerId() {
        if (!currentTurn) return null;
        const playerIds = Object.keys(players).filter(id => !players[id].eliminated);
        if (playerIds.length <= 1) return null;
        const currentIndex = playerIds.indexOf(currentTurn);
        const nextIndex = (currentIndex + 1) % playerIds.length;
        return playerIds[nextIndex];
      }

      function getShape(kind, rot) {
        const SHAPES = {
          I: [
            [[1, 1, 1, 1]],
            [[1], [1], [1], [1]]
          ],
          O: [
            [[1, 1], [1, 1]]
          ],
          T: [
            [[1, 1, 1], [0, 1, 0]],
            [[0, 1], [1, 1], [0, 1]],
            [[0, 1, 0], [1, 1, 1]],
            [[1, 0], [1, 1], [1, 0]]
          ],
          J: [
            [[1, 0, 0], [1, 1, 1]],
            [[1, 1], [1, 0], [1, 0]],
            [[1, 1, 1], [0, 0, 1]],
            [[0, 1], [0, 1], [1, 1]]
          ],
          L: [
            [[0, 0, 1], [1, 1, 1]],
            [[1, 0], [1, 0], [1, 1]],
            [[1, 1, 1], [1, 0, 0]],
            [[1, 1], [0, 1], [0, 1]]
          ],
          S: [
            [[0, 1, 1], [1, 1, 0]],
            [[1, 0], [1, 1], [0, 1]]
          ],
          Z: [
            [[1, 1, 0], [0, 1, 1]],
            [[0, 1], [1, 1], [1, 0]]
          ]
        };
        const forms = SHAPES[kind];
        return forms[Math.min(rot, forms.length - 1)];
      }

      function renderPlayersList() {
        const meId = me;
        playersEl.innerHTML = '';
        Object.values(players).forEach(p => {
          const row = document.createElement('div');
          row.className = 'p' + (p.id === currentTurn ? ' turn' : '') + (p.eliminated ? ' eliminated' : '');
          const dot = document.createElement('div');
          dot.className = 'dot';
          dot.style.background = p.color;
          const name = document.createElement('div');
          name.textContent = (p.id === meId ? 'You' : p.name) + (p.eliminated ? ' (Eliminated)' : p.id === winnerId ? ' (Winner)' : '');
          const pts = document.createElement('div');
          pts.style.width = '90px';
          pts.innerHTML = `
            <div class="apbar"><div class="apfill" style="width:${Math.round((p.points / maxPoints) * 100)}%"></div></div>
            <div class="muted" style="text-align:right;">${p.points} pts</div>
          `;
          row.append(dot, name, pts);
          playersEl.appendChild(row);
        });
      }

      function send(msg) {
        try { ws.send(JSON.stringify(msg)); } catch { }
      }

      const keymap = {
        ArrowLeft: 'left',
        ArrowRight: 'right',
        ArrowDown: 'soft',
        Space: 'hard',
        ArrowUp: 'rotCW',
        KeyQ: 'rotCCW',
        KeyE: 'rotCW'
      };

      document.addEventListener('keydown', (e) => {
        if (!gameStarted) return;
        const act = keymap[e.code];
        if (!act) return;
        e.preventDefault();
        const mePl = players[me];
        if (!mePl || mePl.eliminated) return;
        if (currentTurn !== me && act !== 'left' && act !== 'right') return;
        send({ type: 'move', id: me, dir: act });
      });

    })();
  </script>
</body>

</html>